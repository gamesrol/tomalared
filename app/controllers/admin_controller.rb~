# -*- coding: utf-8 -*-
require_dependency File.join(Rails.root, 'lib', 'ozimodo', 'cookie_auth')
class AdminController < ApplicationController
  include Ozimodo::CookieAuth      # login stuff
#  session :disabled => false
  
 
  # LO HE UNIO Y LE PUESTO REGISTO AL FINAL.... puestos en mas lineas y bla bla bla
  # run the authorize method before we execute
  # any methods (except login) to see if the user
  # is actually logged in or not
  before_filter :authorize,        								
                :except => [:login, :list_post, :create_user]
 			 	
  before_filter	:admin_user_only => [:users, :rename_user, :delete_user]	
                                 
  helper :tumble #, ThemeHelper

  #
  # post management
  #
  
  # we do this a lot.  hrm.
  def index
  end
  
  # new and edit just wrap to the same method
  def new() 
	save_post 
  end
  def edit() 
    if current_user[:id] != params[:user_id] 
      save_post
    end
  end

  # this method handles creation of new posts and editing of existing posts
  def save_post

    if params[:id] && request.get?
      # want to edit a specific post -- go for it
      @post = Post.find(params[:id])
      @tags = @post.tag_names
      render :action => :new
    elsif !params[:id] && request.get?
      # want to create a new post -- go for it
      @post = Post.new
      @tags = nil
      render :action => :new

   	
    elsif request.post?
      # post request means something big is going to happen.
      # set post variable to the post in question if we're editing, otherwise
      # open a new object
      post = params[:id] ? Post.find(params[:id]) : Post.new
      
      # reset all of post's attributes, replacing them with those submitted
      # from the form
      post.attributes = params[:post]
      
      # if post has no user_id set, give it the id of the logged in user
      post.user_id ||= current_user[:id]
      
      # if this is a yaml post type, grab the params we need, yamlize them, 
      # then set them as the content
      type = params[:post_type]
      post.content = params[:content] if TYPES[type]

     # reset all the tag names attached to those submitted
      t11 = ''
      t12 = ''
     if post.post_type == 'quote'
         post.content.split.each do |t|
         t11 = t.scan(/^#\w+/)
         t12 <<= t11.to_s.gsub(/^#/,"") + "\n"
         end
       post.tag_names = "#{t12}"
     else
      post.tag_names = params[:tags]
     end 

    if post.title == 'Titulo'
	post.title = ''
    end 	

    if (post.post_type == 'link' || post.post_type == 'video') 
      require 'metainspector'

        doc = MetaInspector.new(post.content)

      open("#{doc.url}") {|f| f.each_line {|line| p line}
        p f.charset          
        @f = f }

      if @f.charset == 'utf-8'
        title = doc.title
        desc = doc.description
      else
      	title = Iconv.conv('utf-8', @f.charset,doc.title)
      	desc = Iconv.new('utf-8', @f.charset),(doc.description)

      end

      post.title = title
	
      if post.post_type == 'link' && doc.image
        post.content = desc + "\n" + doc.image + "\n" + doc.url
      else
        post.content = desc + "\n" + doc.url
      end
    
end
      # save the post - if it fails, send the user back from whence she came
      if post.save
        flash[:notice] = 'Mensaje se ha guardado correctamente.'
        redirect_to :action => 'list_post'
      else
        flash[:notice] = "Hubo un error al guardar el mensaje."
        render :action => self.action_name
      end
    else
       # i don't know how you'd ever get here but i don't know a lot of things
     # redirect_to :action => :list_post
    end
 	
end

  # ooo, pagination.
  def list
    if params[:id]
	    @user = User.find(params[:id])
    else	
           @user = User.find(current_user[:id])
    end
     	   @posts = Post.find(:all, :conditions => { :user_id => @user.id }, :order => 'id DESC', :limit => '10' )
  end

  def list_post(options = Hash.new)
	@po = Post.new
    if params[:id] 
		@posts = Post.find(:all, :conditions => {:id => params[:id]}, :order => 'id DESC', :limit => '10')
	@uno_solo = true
    else
	if params[:type]
		@posts = Post.find(:all, :conditions => {:post_type=> params[:type]}, :order => 'id DESC', :limit => '10')
	else
		@posts = Post.find(:all, :order => 'id DESC')
	end
    end	
  end

  def list_post_user()
    @po = Post.new

    if params[:name]
      @user = User.find_by_name(params[:name])
    end

    if params[:id]	
      @user = User.find(params[:id])
    end	

    if params[:type]
      @posts = Post.find(:all, :conditions => { :user_id => @user.id , :post_type=> params[:type]}, :order => 'id DESC', :limit => '10')
    else   
      @posts = Post.find(:all, :conditions => { :user_id => @user.id }, :order => 'id DESC', :limit => '10')
    end	
  end

  # grab the post and destroy it.  simple enough.
  def delete
    post = Post.find(params[:id])
    post.destroy
    flash[:notice] = 'Post Borrado.'
    redirect_to :action => :list_post
  end
  
  # could be better.  grab the last post and save it, forcing a refresh of
  # most of our cache.  

  def method_missing(m, *args)
    # check if it's an ajax method
    if self.respond_to?(return_method = "#{m}_return")
      return unless request.post? && logged_in?

      post = Post.find(params[:post_id])

      # ajax_edit_title => title
      property = m.to_s.split('_')[2..-1].join('_')

      post.send("#{property}=", self.instance_eval("params[:post_#{property}]"))

      post.save

      self.send(return_method, post)
    else
      raise NoMethodError, m.to_s
    end
  end

  def ajax_edit_title_return(post)
    render :text => post.title.blank? ? "empty-title" : post.title
  end

  def ajax_edit_tag_names_return(post)
    render :text => unless post.tag_names.empty?
                      post.tag_names.split.map { |t| 
                        '<a href="' << url_for({:controller => 'tumble', :action => 'tag', :tag => t}) << %[" class="tag_link">#{t}</a>"]
                      }.join(' ')
                    else
                      'empty-tags'
                    end
  end

  def ajax_edit_content_return(post)
    post.yaml_content_to_hash!
    render :partial => "post", :locals => { :post => post }
  end
  
  
  #
  # tag management
  #
  
  # ajaxly rename the tag
  def rename_tag
    if request.post? 
      tag = Tag.find(params[:tag_id])
      tag.name = params[:tag_name]
      tag.save
      render :text => tag.name
    end
  end
  
  # up and delete a tag
  def delete_tag
    tag = Tag.find(params[:id])
    tag.destroy
    flash[:notice] = 'Tag deleted.'
    redirect_to :action => :list_tags
  end

  def tag_users
    @tag = Tag.find(params[:id])
    @tags_users = Tag.list_users[@tag.id]

  end 
  
  #
  # user handling
  #
  
  # see if the poor user is authorized
  def authorize 
    redirect_to :controller => 'admin', :action => 'login' unless logged_in?
  end  

  # certain actions only the big man can perform
  def admin_user_only
    redirect_to :controller => 'admin', :action => 'password' unless is_admin_user?
  end

  # the big man
  def is_admin_user?
    (logged_in? && current_user[:id] == User::ADMIN_USER_ID)
  end
  
  # try to login, obviously
  def login
    	if request.post?
      		@user = User.new(params[:user])
      
		# login check is built into the user model
		logged_in_user = @user.try_to_login

		if logged_in_user				
			set_logged_in(logged_in_user, params[:remember_me])
			redirect_to :action => 'list_post_user', :id => current_user[:id]
		else
			flash[:notice] = 'Usuario o Clave incorectos.'
		          @posts = Post.paginate(:page => params[:page], :per_page => 10, :order => 'id DESC')		end
	      # user's already logged in
	      @user = User.new
    	else	
                flash[:notice]    = 'Puedes registrate si rellenas este formulario'	  
       end 
end

  def logout
    set_logged_out
    flash[:notice]    = "Desconectado."

    # if they got here from a page other than the admin section, send them back
    ref = request.env['HTTP_REFERER']
    redirect_to ((ref =~ /admin/ || nil) ? { :action => :login } : :back)
  end

  # user list
  def users
    @users = User.find(:all, :order => 'id ASC')
  end
  
  # ajaxly rename a user
  def rename_user
    if request.post?
      user = User.find(params[:user_id])
      user.name = params[:user_name]
      user.save
      render :text => user.name
    end
  end
  
  # up and delete a user
  def delete_user
    user_id = params[:id]
    user = User.find(user_id)

    flash[:notice] = begin
                       user.destroy
                       Post.chown_posts(user_id,User::ADMIN_USER_ID)
                       "Usuario Borrado."
                     rescue CantDestroyAdminUser
                       "No puede borrar al admin :("
                     end

    redirect_to :action => :users
  end

  # add a new user
  def create_user
    if request.post?
      @user = User.new(params[:user])
      flash[:notice] = case true
                       when !User.password_long_enough?(params[:password][:new])
                         "Tienes que hacer tu contraseña más de cinco letras... Vamos."
                       when !User.passwords_match?(params[:password][:new], params[:password][:confirm])
                         "Las contraseñas no coinciden."
                       end

      return flash[:notice] if flash[:notice]

      @user.password = params[:password][:new]

      if @user.save
        flash[:notice] = "Usuario #{@user.name} creado."
        redirect_to :action => 'users'
      else
        flash[:error] = "Error creando usuario."
      end
    else
      @user = User.new 
    end
  end

  # change your password
  def perfil
    @user = User.find(current_user[:id])

    if params[:id] && is_admin_user?
      @user_id = params[:id].to_i
    elsif params[:id] && !is_admin_user?
      flash[:notice] = "Permiso denegado. Debe ser usuario administrador."
      redirect_to :action => 'users'
    else
      @user_id = current_user[:id]
    end

    if request.post?
      # grab our lovely user
      user = User.find(@user_id)
      
      # see if there's anything wrong with the submitted passwords
      flash[:error] = case true
                      when !User.password_long_enough?(params[:password][:new])
                        "Tienes que hacer tu contraseña más de cinco letras... Vamos."
                      when !User.passwords_match?(params[:password][:new], params[:password][:confirm])
                        "Las contraseñas no coinciden."
                      end

      if params[:password][:old] && User.hash_password(params[:password][:old]) != user.hashed_password
        flash[:error] = "Contraseña anterior está mal, lo siento." 
      end
      
      # end this transaction if we got an error
      return flash[:error] unless flash[:error].nil?
      
      # okay, change the password.
      user.password = params[:password][:new]
      user.save
      
      flash[:notice] = "Clave Cambiada."
    end
  end

  def chat__
  
  end

  # chat
  def chat
    @msg = [] 
    user = User.find(current_user[:id])
    @msg = user.msg
  end

  def maps

  end
    
  def updatedatos
      user = User.find(current_user[:id])
      user.name = params[:name]	
      user.email = params[:email]	
      user.save     	
      redirect_to :action => 'perfil'
  end  
  
  	def updatefoto
	 if request.post?
	 
	     #asigna la información del video en archivo
	     archivo = params[:imagen]
	 
	     #nombre original del archivo
	     name =  archivo.original_filename
	     name1 = "#{current_user[:id]}.jpg"	
	 
	     #ruta donde se guardará el video
	     directory = "public/img"
	 
	     # crear la ruta del archivo
	     path = File.join(directory, name1) 
	 
	     extensionArchivo = name.slice(name.rindex("."), name.length).downcase
	 
	     #verifica que la extensión sea la correcta
	 
		 # crear el archivo
		 File.open(path, "wb") { |f| f.write(archivo.read) }
	 
		 #guarda la información que se mostrará
		 @archivoGuardado = true
		 @nombreArchivo = name
	 end
	redirect_to :action => 'perfil'
	end
end
